<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="print-color-adjust" content="exact">
    <title>8700 Modbus確認用 V8.6</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            font-family: Arial, sans-serif;
        }

        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 20px;
        }

        .top-controls {
            display: flex;
            gap: 5px;
            margin-bottom: 20px;
        }

        .comm-panel {
            background-color: #f0f0f0;
            padding: 15px;
            border-radius: 5px;
            flex-grow: 1;
        }

        .test-button-container {
            background-color: #f0f0f0;
            padding: 15px;
            border-radius: 5px;
            display: flex;
            align-items: center;
        }

        .comm-settings {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .settings-left {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .test-button {
            margin-left: auto;
            padding: 8px 16px;
            background-color: #888;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }

        .test-button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        .main-content {
            display: flex;
            gap: 5px;
            margin-bottom: 20px;
        }

        .status-panel {
            background-color: #f0f0f0;
            padding: 15px;
            border-radius: 5px;
            width: 350px;
        }

        .right-content {
            flex-grow: 1;
        }

        .chart-container {
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 15px;
            height: 400px;
        }

        .command-log {
            margin-top: 20px;
            height: 200px;
            overflow-y: auto;
            background-color: #fff;
            border: 1px solid #ddd;
            padding: 10px;
            border-radius: 5px;
        }

        .status-item {
            background-color: #fff;
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 3px;
        }

        .setting-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .connect-button,
        .test-button {
            padding: 8px 16px;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }

        .connect-button {
            background-color: #4CAF50;
        }

        .test-button {
            background-color: #888;
        }

        .test-button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        .status-text {
            color: #666;
        }

        .log-entry {
            padding: 3px 0;
            border-bottom: 1px solid #eee;
        }

        .log-entry.send {
            color: #0066cc;
        }

        .log-entry.receive {
            color: #006600;
        }

        .log-entry.error {
            color: #cc0000;
        }

        .totalizer-button {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 3px;
            background-color: white;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        .totalizer-button.active {
            background-color: #4CAF50;
            color: white;
            border-color: #4CAF50;
        }

        .test-button.stop {
            background-color: #dc3545;
            margin-left: 10px;
        }

        .test-button.stop:disabled {
            background-color: #ccc;
        }

        /* マニュアル設定用のスタイル */
        .mode-selector {
            margin: 10px 0;
            padding: 10px;
            background-color: #f5f5f5;
            border-radius: 5px;
        }

        .mode-selector label {
            margin-right: 20px;
            cursor: pointer;
        }

        .manual-controls {
            display: none;
            margin-top: 15px;
            margin-bottom: 15px;
            padding: 15px;
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 5px;
        }

        .manual-controls.active {
            display: block;
        }

        .manual-input-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .manual-input-group input {
            width: 100px;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 3px;
        }

        .manual-button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }

        .manual-button.set {
            background-color: #4CAF50;
            color: white;
        }

        .manual-button.close {
            background-color: #ff9800;
            color: white;
        }

        .manual-button:hover {
            opacity: 0.8;
        }

        .manual-button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        /* 印刷用スタイル - 横向き */
        @media print {
            @page {
                size: A4 landscape;
                margin: 10mm;
            }

            .mode-selector,
            .manual-controls,
            .command-history {
                display: none !important;
            }

            .container {
                max-width: 100%;
                padding: 0;
                margin: 0;
                width: 100%;
            }

            body {
                font-size: 11pt;
            }

            h1 {
                margin-bottom: 10px;
            }

            .comm-panel,
            .test-button-container {
                padding: 8px;
                margin-bottom: 5px;
            }

            .main-content {
                gap: 5px;
                page-break-inside: avoid;
                margin-bottom: 5px;
            }

            .status-panel {
                width: 250px;
                padding: 10px;
            }

            .status-item {
                margin-bottom: 5px;
                padding: 5px;
            }

            .right-content {
                width: calc(100% - 270px);
                height: 270px !important;
            }

            .chart-container {
                position: relative;
                height: 250px !important;
                min-height: 250px !important;
                padding: 10px;
                margin-bottom: 10px;
            }

            .chart-container canvas {
                position: absolute !important;
                height: 100% !important;
                width: 100% !important;
            }

            .command-log {
                height: 120px;
                overflow: visible;
                padding: 5px;
            }

            * {
                -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
            }

            .connect-button,
            .test-button {
                border: 1px solid #666;
            }

            .status-label,
            .status-text {
                font-size: 10pt;
            }

            .log-entry {
                font-size: 9pt;
                margin: 2px 0;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>8700MCシリーズModbus仕様確認プログラム V8.6</h1>

        <div class="top-controls">
            <div class="comm-panel">
                <div class="comm-settings">
                    <div class="setting-item">
                        <label for="baudRate">通信速度:</label>
                        <select id="baudRate">
                            <option value="9600">9600 bps</option>
                            <option value="19200">19200 bps</option>
                            <option value="38400">38400 bps</option>
                            <option value="51200">51200 bps</option>
                            <option value="76800">76800 bps</option>
                            <option value="115200">115200 bps</option>
                        </select>
                    </div>
                    <div class="setting-item">
                        <label for="parity">パリティ:</label>
                        <select id="parity">
                            <option value="none">なし (None)</option>
                            <option value="even">偶数 (Even)</option>
                            <option value="odd">奇数 (Odd)</option>
                        </select>
                    </div>
                    <div class="setting-item">
                        <label for="deviceId">デバイスID:</label>
                        <input type="number" id="deviceId" min="1" max="247" value="1" style="width: 60px;">
                    </div>
                    <button id="connectButton" class="connect-button">接続</button>
                    <span id="connectionStatus" class="status-text">未接続</span>
                </div>
            </div>
            <div class="test-button-container">
                <button id="startTest" class="test-button" disabled>流量検査開始</button>
                <button id="stopTest" class="test-button stop" disabled>停止</button>
            </div>
        </div>

        <div class="mode-selector">
            <label>
                <input type="radio" name="testMode" value="auto" checked>
                自動検査
            </label>
            <label>
                <input type="radio" name="testMode" value="manual">
                マニュアル設定
            </label>
        </div>

        <div id="manualControls" class="manual-controls">
            <div class="manual-input-group">
                <label>設定値 (%):</label>
                <input type="number" id="manualFlowInput" min="0" max="100" step="1" placeholder="0-100">
                <span>%</span>
                <button id="manualSetButton" class="manual-button set" disabled>設定</button>
                <button id="fullCloseButton" class="manual-button close" disabled>Full Close</button>
            </div>
        </div>

        <div class="main-content">
            <div class="status-panel">
                <div class="status-item">
                    <span class="status-label">RUNキー状態:</span>
                    <span id="runKeyStatus">読み込み中...</span>
                </div>
                <div class="status-item">
                    <span class="status-label">設定モード:</span>
                    <span id="settingMode">読み込み中...</span>
                </div>
                <div class="status-item">
                    <span class="status-label">オートゼロ状態:</span>
                    <span id="autoZeroStatus">読み込み中...</span>
                </div>
                <div class="status-item">
                    <span class="status-label">0-2%表示設定:</span>
                    <span id="displayMode">読み込み中...</span>
                </div>
                <div class="status-item">
                    <span class="status-label">流量レンジ:</span>
                    <span id="flowRange">読み込み中...</span>
                </div>
            </div>

            <div class="right-content">
                <div class="chart-container">
                    <canvas id="flowChart"></canvas>
                </div>
            </div>
        </div>

        <div class="command-history">
            <h3>通信履歴</h3>
            <div id="commandLog" class="command-log"></div>
        </div>

    </div>

<script>
    // ModbusCommands クラス
    class ModbusCommands {
        static calculateCRC(data, length) {
            let crc = 0xFFFF;
            for (let i = 0; i < length; i++) {
                crc ^= data[i];
                for (let j = 0; j < 8; j++) {
                    if (crc & 0x0001) {
                        crc = (crc >> 1) ^ 0xA001;
                    } else {
                        crc = crc >> 1;
                    }
                }
            }
            return [crc & 0xFF, (crc >> 8) & 0xFF];
        }
        static createCommand(command) {
            const crc = this.calculateCRC(command, command.length - 2);
            command[command.length - 2] = crc[0];
            command[command.length - 1] = crc[1];
            return command;
        }
        static createReadCoilStatus() {
            const deviceId = parseInt(document.getElementById('deviceId').value) || 1;
            return this.createCommand(new Uint8Array([deviceId, 0x01, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00]));
        }
        static createReadFlowRateOutput() {
            const deviceId = parseInt(document.getElementById('deviceId').value) || 1;
            return this.createCommand(new Uint8Array([deviceId, 0x04, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00]));
        }
        static createReadFlowRateRange() {
            const deviceId = parseInt(document.getElementById('deviceId').value) || 1;
            return this.createCommand(new Uint8Array([deviceId, 0x03, 0x00, 0x1B, 0x00, 0x01, 0x00, 0x00]));
        }
        static createReadDecimalPoint() {
            const deviceId = parseInt(document.getElementById('deviceId').value) || 1;
            return this.createCommand(new Uint8Array([deviceId, 0x03, 0x00, 0x08, 0x00, 0x01, 0x00, 0x00]));
        }
        static createWriteFlowRateSetpoint(value) {
            const deviceId = parseInt(document.getElementById('deviceId').value) || 1;
            return this.createCommand(new Uint8Array([deviceId, 0x06, 0x00, 0x15, (value >> 8) & 0xFF, value & 0xFF, 0x00, 0x00]));
        }
        static createWriteControlMode(mode) {
            const deviceId = parseInt(document.getElementById('deviceId').value) || 1;
            return this.createCommand(new Uint8Array([deviceId, 0x06, 0x00, 0x1C, 0x00, mode, 0x00, 0x00]));
        }
    }

    // SerialConnection クラス
    class SerialConnection {
        constructor() {
            this.port = null;
            this.reader = null;
            this.writer = null;
            this.monitor = null;
        }
        setMonitor(monitor) {
            this.monitor = monitor;
        }
        async connect() {
            try {
                if (this.port) {
                    await this.disconnect();
                    return false;
                }
                const baudRate = parseInt(document.getElementById('baudRate').value);
                const parity = document.getElementById('parity').value;
                this.port = await navigator.serial.requestPort();
                await this.port.open({
                    baudRate,
                    dataBits: 8,
                    stopBits: 1,
                    parity,
                    bufferSize: 255
                });
                this.reader = this.port.readable.getReader();
                this.writer = this.port.writable.getWriter();
                return true;
            } catch (error) {
                console.error('Connection error:', error);
                if (this.monitor) this.monitor.addErrorLog(error);
                return false;
            }
        }
        async disconnect() {
            try {
                if (this.reader) {
                    await this.reader.cancel();
                    await this.reader.releaseLock();
                }
                if (this.writer) {
                    await this.writer.close();
                    await this.writer.releaseLock();
                }
                if (this.port) await this.port.close();
            } finally {
                this.port = null;
                this.reader = null;
                this.writer = null;
            }
        }
        async readResponse() {
            if (!this.reader) return null;
            try {
                const response = [];
                let timeout = setTimeout(() => {
                    console.warn('Read timeout occurred');
                    if (this.reader) this.reader.cancel();
                }, 1000);

                const startTime = Date.now();
                while (true) {
                    const {
                        value,
                        done
                    } = await this.reader.read();

                    if (done) {
                        console.warn('Reader done unexpectedly');
                        break;
                    }

                    if (value) {
                        response.push(...value);
                    }

                    // Modbus RTUの最小応答長をチェック
                    if (response.length >= 5) {
                        // Function code 0x01, 0x03, 0x04, 0x06に応じた長さチェック
                        const fc = response[1];
                        let expectedLength = 0;

                        switch (fc) {
                            case 0x01: // Read Coil Status
                            case 0x03: // Read Holding Registers
                            case 0x04: // Read Input Registers
                                if (response.length >= 3) {
                                    expectedLength = response[2] + 5; // Address + FC + ByteCount + Data + CRC
                                }
                                break;
                            case 0x06: // Write Single Register
                                expectedLength = 8; // Fixed length
                                break;
                            default:
                                if (fc >= 0x80) { // Error response
                                    expectedLength = 5; // Address + FC + Exception + CRC
                                }
                        }

                        if (expectedLength > 0 && response.length >= expectedLength) {
                            break;
                        }
                    }

                    // タイムアウトチェック
                    if (Date.now() - startTime > 900) {
                        console.warn('Read timeout - partial data received:', response);
                        break;
                    }
                }

                clearTimeout(timeout);

                if (response.length === 0) {
                    console.error('No response received');
                    return null;
                }

                return new Uint8Array(response);
            } catch (error) {
                console.error('Read response error:', error);
                if (this.monitor) this.monitor.addErrorLog(error);

                // リーダーをリセット
                try {
                    if (this.reader) {
                        await this.reader.cancel();
                        await this.reader.releaseLock();
                        this.reader = this.port.readable.getReader();
                    }
                } catch (resetError) {
                    console.error('Failed to reset reader:', resetError);
                }

                return null;
            }
        }
        async sendCommand(command) {
            if (!this.writer) return null;
            try {
                if (this.monitor) this.monitor.addLogEntry('send', command, this.getCommandDescription(command));

                // 送信前に少し待機（前の通信との間隔を確保）
                await new Promise(resolve => setTimeout(resolve, 50));

                await this.writer.write(command);
                const response = await this.readResponse();

                if (response && this.monitor) {
                    this.monitor.addLogEntry('receive', response, this.getResponseDescription(response));
                } else if (!response) {
                    console.warn('No response received for command:', command);
                    if (this.monitor) {
                        this.monitor.addLogEntry('error', [], 'No response received');
                    }
                }

                return response;
            } catch (error) {
                console.error('Send command error:', error);
                if (this.monitor) this.monitor.addErrorLog(error);
                return null;
            }
        }
        getCommandDescription(command) {
            if (!command || command.length < 2) return '';
            const fc = command[1];
            switch (fc) {
                case 0x01:
                    return 'Read Coil Status';
                case 0x03:
                    const addr = (command[2] << 8) | command[3];
                    switch (addr) {
                        case 0x08:
                            return 'Read Decimal Point (40009)';
                        case 0x1B:
                            return 'Read Flow Rate Range (40028)';
                        default:
                            return `Read Holding Registers (${addr + 40001})`;
                    }
                case 0x04:
                    return 'Read Flow Rate Output (30001)';
                case 0x06:
                    const writeAddr = (command[2] << 8) | command[3];
                    const value = (command[4] << 8) | command[5];
                    switch (writeAddr) {
                        case 0x15:
                            return `Write Flow Rate Setpoint (40022): ${value}`;
                        case 0x1C:
                            return `Write Control Mode (40029): ${value}`;
                        default:
                            return `Write Single Register (${writeAddr + 40001}): ${value}`;
                    }
                default:
                    return '';
            }
        }
        getResponseDescription(response) {
            if (!response || response.length < 3) return '';
            const fc = response[1];
            switch (fc) {
                case 0x01:
                    return `Coil Status: ${response[3].toString(2).padStart(8, '0')}`;
                case 0x03:
                case 0x04:
                    return `Value: ${(response[3] << 8) | response[4]}`;
                case 0x06:
                    return `Written Value: ${(response[4] << 8) | response[5]}`;
                default:
                    return '';
            }
        }
        isConnected() {
            return this.port !== null;
        }
    }

    // FlowChartManager クラス
    class FlowChartManager {
        constructor() {
            this.chart = null;
            this.flowData = [];
            this.startTime = null;
            this.chartInitialized = false;
            this.maxRange = 0;
        }
        async initialize() {
            if (this.chartInitialized) return;
            try {
                if (typeof Chart === 'undefined') await new Promise(resolve => setTimeout(resolve, 100));
                const canvas = document.getElementById('flowChart');
                if (!canvas) return;
                this.chart = new Chart(canvas, {
                    type: 'line',
                    data: {
                        datasets: [{
                            label: '流量',
                            data: [],
                            borderColor: 'rgb(75, 192, 192)',
                            tension: 0.1,
                            pointRadius: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        animation: false,
                        plugins: {
                            legend: {
                                display: false
                            },
                            title: {
                                display: true,
                                text: '出力モニター'
                            }
                        },
                        scales: {
                            x: {
                                type: 'linear',
                                title: {
                                    display: true,
                                    text: '経過時間 (秒)'
                                },
                                min: 0,
                                max: 200
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: '流量'
                                },
                                beginAtZero: true
                            }
                        }
                    }
                });
                this.chartInitialized = true;
            } catch (error) {
                console.error('Chart initialization error:', error);
            }
        }
        async resetChart() {
            if (!this.chart) return;
            this.flowData = [];
            this.startTime = Date.now();
            this.chart.data.datasets[0].data = [];
            this.chart.options.scales.x.min = 0;
            this.chart.options.scales.x.max = 200;
            this.chart.update('none');
        }
        async updateChart(value) {
            if (!this.chartInitialized) await this.initialize();
            if (!this.startTime) this.startTime = Date.now();
            let elapsed = (Date.now() - this.startTime) / 1000;
            if (elapsed > 200) {
                await this.resetChart();
                elapsed = (Date.now() - this.startTime) / 1000;
            }
            this.flowData.push({
                x: elapsed,
                y: value
            });
            this.chart.data.datasets[0].data = this.flowData;
            this.chart.update('none');
        }
        setMaxRange(range) {
            this.maxRange = range;
            if (this.chart && this.chart.options.scales.y) {
                this.chart.options.scales.y.max = range * 1.2;
                this.chart.update('none');
            }
        }
    }

    // ModbusMonitor メインクラス
    class ModbusMonitor {
        constructor() {
            this.serialConnection = new SerialConnection();
            this.serialConnection.setMonitor(this);
            this.chartManager = new FlowChartManager();
            this.isTestRunning = false;
            this.maxRange = 0;
            this.decimalPoint = 0;
            this.updateInterval = null;
            this.stopRequested = false;
            this.commandLog = document.getElementById('commandLog');
            this.currentMode = 'auto';
            this.isManualModePaused = false;
            this.currentControlMode = 0;
            this.pendingCommand = null;
            this.isUpdating = false;
        }

        addLogEntry(type, data, description = '') {
            const now = new Date();
            const timestamp = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}.${now.getMilliseconds().toString().padStart(3, '0')}`;
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            const hexData = Array.from(data).map(byte => byte.toString(16).padStart(2, '0').toUpperCase()).join(' ');
            entry.textContent = `${timestamp} ${type === 'send' ? '→' : '←'} ${hexData} ${description}`;
            this.commandLog.insertBefore(entry, this.commandLog.firstChild);
            if (this.commandLog.children.length > 100) {
                this.commandLog.removeChild(this.commandLog.lastChild);
            }
        }

        addErrorLog(error) {
            const entry = document.createElement('div');
            entry.className = 'log-entry error';
            entry.textContent = `${new Date().toLocaleTimeString()} ERROR: ${error.message || error}`;
            this.commandLog.insertBefore(entry, this.commandLog.firstChild);
        }

        async initialize() {
            try {
                await this.chartManager.initialize();
                this.setupEventListeners();
                this.setupModeSelector();
            } catch (error) {
                console.error('ModbusMonitor initialization error:', error);
                document.querySelector('.chart-container').textContent = `初期化エラー: ${error.message}`;
            }
        }

        setupModeSelector() {
            const modeRadios = document.querySelectorAll('input[name="testMode"]');
            const manualControls = document.getElementById('manualControls');
            const startTestButton = document.getElementById('startTest');
            const stopButton = document.getElementById('stopTest');

            modeRadios.forEach(radio => {
                radio.addEventListener('change', async (e) => {
                    this.currentMode = e.target.value;
                    this.stopPeriodicUpdate();
                    await this.chartManager.resetChart();

                    if (this.currentMode === 'manual') {
                        manualControls.classList.add('active');
                        startTestButton.style.display = 'none';
                        this.isManualModePaused = false;
                        stopButton.textContent = '停止';
                        if (this.serialConnection.isConnected()) {
                            document.getElementById('manualSetButton').disabled = false;
                            document.getElementById('fullCloseButton').disabled = false;
                        }
                    } else {
                        manualControls.classList.remove('active');
                        startTestButton.style.display = 'inline-block';
                        stopButton.textContent = '停止';
                    }

                    if (this.serialConnection.isConnected()) {
                        this.startPeriodicUpdate();
                    }
                });
            });

            document.getElementById('manualSetButton').addEventListener('click', async () => {
                const input = document.getElementById('manualFlowInput');
                const value = parseFloat(input.value);
                if (!isNaN(value) && value >= 0 && value <= 100) {
                    console.log(`Setting manual flow to ${value}%`);
                    await this.setManualFlow(value);
                } else {
                    alert('0から100の間の数値を入力してください。');
                }
            });

            document.getElementById('fullCloseButton').addEventListener('click', async () => {
                console.log('Setting Full Close');
                await this.setFullClose();
            });
        }

        async setManualFlow(percentage) {
            // 新しいコマンドをセット
            this.pendingCommand = async () => {
                const setValue = Math.floor(this.maxRange * (percentage / 100.0));

                // 制御モードを確認し、必要に応じて切り替え
                if (this.currentControlMode !== 1) {
                    await this.serialConnection.sendCommand(ModbusCommands.createWriteControlMode(1));
                    this.currentControlMode = 1;
                    await this.sleep(300);
                }

                // 設定値を送信
                await this.serialConnection.sendCommand(ModbusCommands.createWriteFlowRateSetpoint(setValue));
                await this.sleep(300);

                this.addLogEntry('info', [], `Manual flow set to: ${percentage}% (value: ${setValue})`);

                // Pause状態を解除
                if (this.isManualModePaused) {
                    this.isManualModePaused = false;
                    document.getElementById('stopTest').textContent = '停止';
                }
            };
        }

        async setFullClose() {
            // 新しいコマンドをセット
            this.pendingCommand = async () => {
                await this.serialConnection.sendCommand(ModbusCommands.createWriteFlowRateSetpoint(0));
                await this.sleep(300);

                await this.serialConnection.sendCommand(ModbusCommands.createWriteControlMode(2));
                this.currentControlMode = 2;
                await this.sleep(300);

                this.addLogEntry('info', [], 'Full Close mode activated');
                document.getElementById('manualFlowInput').value = '';
            };
        }

        async determineFlowUnit() {
            try {
                const rangeResponse = await this.serialConnection.sendCommand(ModbusCommands.createReadFlowRateRange());
                const decimalResponse = await this.serialConnection.sendCommand(ModbusCommands.createReadDecimalPoint());
                if (!rangeResponse || !decimalResponse) {
                    document.getElementById('flowRange').textContent = 'エラー';
                    return;
                }
                this.maxRange = (rangeResponse[3] << 8) | rangeResponse[4];
                this.decimalPoint = (decimalResponse[3] << 8) | decimalResponse[4];
                const adjustedRange = this.adjustFlowValueByDecimalPoint(this.maxRange);
                document.getElementById('flowRange').textContent = adjustedRange.toFixed(this.decimalPoint);
                this.chartManager.setMaxRange(adjustedRange);

                console.log(`Flow range determined: maxRange=${this.maxRange}, decimalPoint=${this.decimalPoint}, adjustedRange=${adjustedRange}`);
            } catch (error) {
                console.error('Error determining flow parameters:', error);
                document.getElementById('flowRange').textContent = 'エラー';
                this.addErrorLog(error);
            }
        }

        async updateCoilStatus() {
            const response = await this.serialConnection.sendCommand(ModbusCommands.createReadCoilStatus());
            if (!response || response.length < 4) return;
            const statusByte = response[3];
            document.getElementById('runKeyStatus').textContent = (statusByte & 0x01) ? 'RUNキー使用中' : 'RUNキー不使用';
            document.getElementById('settingMode').textContent = (statusByte & 0x02) ? 'アナログ設定' : 'デジタル設定';
            document.getElementById('autoZeroStatus').textContent = (statusByte & 0x10) ? 'オートゼロ使用中' : 'オートゼロ不使用';
            document.getElementById('displayMode').textContent = (statusByte & 0x20) ? '0-2％の時0表示' : '0-2%範囲表示';
        }

        async updateFlowRate() {
            const response = await this.serialConnection.sendCommand(ModbusCommands.createReadFlowRateOutput());
            if (!response || response.length < 5) return;

            // 符号付き16ビット整数として処理
            let flowValue = (response[3] << 8) | response[4];

            // 負の値の処理（2の補数）
            if (flowValue > 32767) {
                flowValue = flowValue - 65536;
            }

            // 負の値は0として扱う
            if (flowValue < 0) {
                flowValue = 0;
            }

            const adjustedFlow = this.adjustFlowValueByDecimalPoint(flowValue);
            await this.chartManager.updateChart(adjustedFlow);
        }

        setupEventListeners() {
            document.getElementById('connectButton').addEventListener('click', async () => {
                if (!this.serialConnection.isConnected()) {
                    if (await this.serialConnection.connect()) {
                        document.getElementById('connectionStatus').textContent = '接続済み';
                        document.getElementById('startTest').disabled = false;
                        document.getElementById('stopTest').disabled = false;
                        document.getElementById('connectButton').textContent = '切断';
                        if (this.currentMode === 'manual') {
                            document.getElementById('manualSetButton').disabled = false;
                            document.getElementById('fullCloseButton').disabled = false;
                        }
                        await this.sleep(500);
                        await this.determineFlowUnit();
                        await this.chartManager.resetChart();
                        this.currentControlMode = 0;
                        this.startPeriodicUpdate();
                    }
                } else {
                    await this.serialConnection.disconnect();
                    document.getElementById('connectionStatus').textContent = '未接続';
                    document.getElementById('startTest').disabled = true;
                    document.getElementById('stopTest').disabled = true;
                    document.getElementById('connectButton').textContent = '接続';
                    document.getElementById('manualSetButton').disabled = true;
                    document.getElementById('fullCloseButton').disabled = true;
                    this.stopPeriodicUpdate();
                }
            });

            document.getElementById('startTest').addEventListener('click', async () => await this.runFlowTest());

            document.getElementById('stopTest').addEventListener('click', async () => {
                if (this.currentMode === 'manual') {
                    const stopButton = document.getElementById('stopTest');
                    if (this.isManualModePaused) {
                        // クリア&再開の処理
                        await this.chartManager.resetChart();
                        this.isManualModePaused = false;
                        stopButton.textContent = '停止';
                        // タイマーを強制的に再起動
                        this.stopPeriodicUpdate();
                        await this.sleep(100);
                        this.startPeriodicUpdate();
                    } else {
                        // 停止の処理
                        this.isManualModePaused = true;
                        stopButton.textContent = 'クリア & 再開';
                        this.stopPeriodicUpdate();
                    }
                } else {
                    await this.stopFlowTest();
                }
            });

        }

        adjustFlowValueByDecimalPoint(value) {
            return value / Math.pow(10, this.decimalPoint);
        }

        async runFlowTest() {
            if (this.isTestRunning) return;
            this.isTestRunning = true;
            this.stopRequested = false;
            const startTestButton = document.getElementById('startTest');
            const stopTestButton = document.getElementById('stopTest');
            startTestButton.disabled = true;
            stopTestButton.disabled = false;

            try {
                this.stopPeriodicUpdate();
                await this.chartManager.resetChart();
                this.chartManager.chart.options.plugins.title.text = '出力モニター（5%,10%,20%F.S.刻みで10s間）';
                const steps = [0.05, 0.1, 0.2, 0.4, 0.6, 0.8, 1.0];
                const setPoints = steps.map(step => Math.floor(this.maxRange * step));
                const readInterval = 200;

                for (const setValue of setPoints) {
                    if (this.stopRequested) break;
                    let elapsedSeconds = this.chartManager.startTime ? (Date.now() - this.chartManager.startTime) / 1000 : 0;
                    await this.serialConnection.sendCommand(ModbusCommands.createWriteControlMode(2));
                    await this.sleep(500);
                    let targetTime = elapsedSeconds + 11.5;
                    while (elapsedSeconds < targetTime) {
                        if (this.stopRequested) break;
                        await this.updateFlowRate();
                        await this.sleep(readInterval);
                        elapsedSeconds = (Date.now() - this.chartManager.startTime) / 1000;
                    }
                    if (this.stopRequested) break;
                    await this.serialConnection.sendCommand(ModbusCommands.createWriteFlowRateSetpoint(setValue));
                    await this.sleep(100);
                    await this.serialConnection.sendCommand(ModbusCommands.createWriteControlMode(1));
                    await this.sleep(500);
                    for (let i = 0; i < 3; i++) {
                        if (this.stopRequested) break;
                        await this.serialConnection.sendCommand(ModbusCommands.createReadFlowRateOutput());
                        await this.sleep(50);
                    }
                    targetTime = (this.chartManager.startTime ? (Date.now() - this.chartManager.startTime) / 1000 : 0) + 12;
                    while (elapsedSeconds < targetTime) {
                        if (this.stopRequested) break;
                        await this.updateFlowRate();
                        await this.sleep(readInterval);
                        elapsedSeconds = (Date.now() - this.chartManager.startTime) / 1000;
                    }
                }

                // 100%設定後、Closeまでの波形を追加
                if (!this.stopRequested) {
                    // 100%の状態をさらに10秒間保持
                    let elapsedSeconds = (Date.now() - this.chartManager.startTime) / 1000;
                    let targetTime = elapsedSeconds + 5;
                    while (elapsedSeconds < targetTime) {
                        if (this.stopRequested) break;
                        await this.updateFlowRate();
                        await this.sleep(readInterval);
                        elapsedSeconds = (Date.now() - this.chartManager.startTime) / 1000;
                    }

                    // Full Closeに切り替え
                    if (!this.stopRequested) {
                        await this.serialConnection.sendCommand(ModbusCommands.createWriteControlMode(2));
                        await this.sleep(500);
                        await this.serialConnection.sendCommand(ModbusCommands.createWriteFlowRateSetpoint(0));
                        await this.sleep(500);

                        // Close後の波形を10秒間記録
                        elapsedSeconds = (Date.now() - this.chartManager.startTime) / 1000;
                        targetTime = elapsedSeconds + 10;
                        while (elapsedSeconds < targetTime) {
                            if (this.stopRequested) break;
                            await this.updateFlowRate();
                            await this.sleep(readInterval);
                            elapsedSeconds = (Date.now() - this.chartManager.startTime) / 1000;
                        }
                    }
                }
            } catch (error) {
                console.error('Flow test error:', error);
                this.addErrorLog(error);
            } finally {
                this.isTestRunning = false;
                this.stopRequested = false;
                startTestButton.disabled = false;
                stopTestButton.disabled = this.serialConnection.isConnected() ? false : true;
                this.startPeriodicUpdate();
                this.chartManager.chart.options.plugins.title.text = '出力モニター';
            }
        }

        async stopFlowTest() {
            if (this.isTestRunning) {
                this.stopRequested = true;
                document.getElementById('stopTest').disabled = true;
            }
        }

        async periodicUpdateTask() {
            if (this.isUpdating) return;

            this.isUpdating = true;
            try {
                // ペンディングコマンドがあれば実行
                if (this.pendingCommand) {
                    const cmd = this.pendingCommand;
                    this.pendingCommand = null;
                    await cmd();
                }

                // 通常の更新（エラーが発生しても継続）
                try {
                    await this.updateCoilStatus();
                } catch (error) {
                    console.error('Coil status update error:', error);
                }

                if (this.currentMode === 'manual' && !this.isManualModePaused) {
                    try {
                        await this.updateFlowRate();
                    } catch (error) {
                        console.error('Flow rate update error:', error);
                    }
                }
            } catch (error) {
                console.error('Periodic update error:', error);
            } finally {
                this.isUpdating = false;
            }
        }

        startPeriodicUpdate() {
            // 既存のタイマーがある場合は停止
            this.stopPeriodicUpdate();

            // 新しいタイマーを開始
            this.updateInterval = setInterval(() => {
                this.periodicUpdateTask();
            }, 500);

            console.log('Periodic update started');
        }

        stopPeriodicUpdate() {
            if (this.updateInterval) {
                clearInterval(this.updateInterval);
                this.updateInterval = null;
                console.log('Periodic update stopped');
            }
        }

        sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
    }

    if ('serial' in navigator) {
        const monitor = new ModbusMonitor();
        monitor.initialize();
    } else {
        alert('このブラウザはWeb Serial APIをサポートしていません。\nChrome/Edge等の対応ブラウザをご使用ください。');
    }
</script>
</body>
</html>
